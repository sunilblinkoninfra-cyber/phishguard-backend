import logging
import hashlib
from typing import Dict
# import clamd  # Hidden for MVP - optional ClamAV friend (add later with 'pyclamd' in recipe)

from core.config import settings

logger = logging.getLogger(__name__)

class MalwareScanner:
    """Malware scanning service using ClamAV (optional)"""
    
    def __init__(self):
        self.use_clamav = self._check_clamav_available()
        if not self.use_clamav:
            logger.warning("ClamAV not available, using heuristic scanning only")
    
    def _check_clamav_available(self) -> bool:
        """Check if ClamAV is available (optional)"""
        try:
            # import clamd  # Uncomment when 'pyclamd' in recipe
            # cd = clamd.ClamdNetworkSocket(
            #     host=settings.CLAMAV_HOST,
            #     port=settings.CLAMAV_PORT,
            #     timeout=5
            # )
            # cd.ping()
            # return True
            logger.info("ClamAV skipped for MVP - heuristics only")
            return False  # Safe fallback
        except Exception as e:
            logger.warning(f"ClamAV not available: {e}")
            return False
    
    async def scan_file(self, filename: str, content: bytes) -> Dict:
        """
        Scan file for malware (heuristics only for MVP)
        
        Returns:
            Dict with scan results including threat detection
        """
        result = {
            "filename": filename,
            "size": len(content),
            "is_infected": False,
            "threats": [],
            "scan_method": "heuristic",
            "file_type": self._guess_file_type(filename, content),  # Safe fallback
            "hashes": self._calculate_hashes(content)
        }
        
        # ClamAV scan if available (optional for MVP)
        if self.use_clamav:
            try:
                # cd = clamd.ClamdNetworkSocket(
                #     host=settings.CLAMAV_HOST,
                #     port=settings.CLAMAV_PORT,
                #     timeout=5
                # )
                # scan_result = cd.scan_stream(content)
                # if scan_result and scan_result[0][0] == '/stream':
                #     if scan_result[0][1]['stream'] == 'OK':
                #         logger.info(f"ClamAV clean: {filename}")
                #     else:
                #         result["is_infected"] = True
                #         result["threats"].append({
                #             "type": "clamav",
                #             "severity": "high",
                #             "description": f"ClamAV detected: {scan_result[0][1]['stream']}"
                #         })
                #         logger.warning(f"ClamAV threat in {filename}: {scan_result[0][1]['stream']}")
                #         result["scan_method"] = "clamav"
                # else:
                #     logger.warning("ClamAV scan failed for {filename}")
                logger.info("ClamAV skipped for MVP - heuristics only")
            except Exception as e:
                logger.error(f"ClamAV scan error: {e}")
                result["scan_method"] = "heuristic"
        
        # Heuristic scan (always runs – MVP star!)
        heuristic_result = self._heuristic_scan(filename, content)
        if heuristic_result["suspicious"]:
            result["is_infected"] = True
            result["threats"].extend(heuristic_result["indicators"])
            if "clamav" not in result["scan_method"]:
                result["scan_method"] = "heuristic"
        
        return result
    
    def _guess_file_type(self, filename: str, content: bytes) -> str:
        """Safe fallback for file type detection (no magic needed)"""
        filename_lower = filename.lower()
        
        # Simple extension-based detection
        if filename_lower.endswith(('.exe', '.dll', '.scr')):
            return "application/x-executable"
        elif filename_lower.endswith(('.pdf',)):
            return "application/pdf"
        elif filename_lower.endswith(('.doc', '.docx')):
            return "application/msword"
        elif filename_lower.endswith(('.xls', '.xlsx')):
            return "application/vnd.ms-excel"
        elif filename_lower.endswith(('.zip', '.rar', '.7z')):
            return "application/zip"
        elif filename_lower.endswith(('.txt',)):
            return "text/plain"
        else:
            # Byte-based guess (first few bytes)
            if content.startswith(b'\x25\x50\x44\x46'):
                return "application/pdf"
            elif content.startswith(b'\xD0\xCF\x11\xE0'):
                return "application/msword"
            elif content.startswith(b'PK'):
                return "application/zip"
            else:
                return "unknown/binary"
    
    def _calculate_hashes(self, content: bytes) -> Dict:
        """Calculate file hashes (always safe)"""
        md5_hash = hashlib.md5(content).hexdigest()
        sha256_hash = hashlib.sha256(content).hexdigest()
        return {
            "md5": md5_hash,
            "sha256": sha256_hash
        }
    
    def _heuristic_scan(self, filename: str, content: bytes) -> Dict:
        """Heuristic scanning for suspicious content (MVP hero!)"""
        filename_lower = filename.lower()
        content_str = content.decode('utf-8', errors='ignore').lower()
        
        indicators = []
        suspicious = False
        
        # Check for suspicious strings
        suspicious_strings = [
            'free money', 'your account has been suspended', 'click here to verify',
            'win a prize', 'urgent action required', 'bank account compromised',
            'password reset required', 'your package is waiting', 'lottery winner'
        ]
        
        found_strings = [s for s in suspicious_strings if s in content_str]
        if found_strings:
            indicators.append({
                "type": "suspicious_strings",
                "severity": "high",
                "description": f"Suspicious strings found: {', '.join(found_strings)}"
            })
            suspicious = True
        
        # Check for packed/obfuscated executables
        if filename_lower.endswith(('.exe', '.dll')):
            # High entropy suggests packing/encryption
            entropy = self._calculate_entropy(content[:10000])
            if entropy > 7.5:  # High entropy threshold
                indicators.append({
                    "type": "high_entropy",
                    "severity": "medium",
                    "description": "File appears packed or encrypted"
                })
                suspicious = True
        
        return {
            "suspicious": suspicious,
            "indicators": indicators
        }
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data (always safe)"""
        if not data:
            return 0.0
        
        entropy = 0
        for x in range(256):
            p_x = float(data.count(bytes([x]))) / len(data)
            if p_x > 0:
                entropy += - p_x * (p_x ** 0.5)
        
        return entropy
    
    async def scan_url_file(self, url: str) -> Dict:
        """
        Scan a file from URL (MVP stub – add later)
        """
        logger.info("URL file scan stub – implement with safety checks")
        return {"filename": url, "is_infected": False, "threats": []}