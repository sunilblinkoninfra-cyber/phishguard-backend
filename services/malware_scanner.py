import logging
import hashlib
import magic
from typing import Dict
import clamd

from core.config import settings

logger = logging.getLogger(__name__)

class MalwareScanner:
    """Malware scanning service using ClamAV"""
    
    def __init__(self):
        self.use_clamav = self._check_clamav_available()
        if not self.use_clamav:
            logger.warning("ClamAV not available, using heuristic scanning only")
    
    def _check_clamav_available(self) -> bool:
        """Check if ClamAV is available"""
        try:
            cd = clamd.ClamdNetworkSocket(
                host=settings.CLAMAV_HOST,
                port=settings.CLAMAV_PORT,
                timeout=5
            )
            cd.ping()
            return True
        except Exception as e:
            logger.warning(f"ClamAV not available: {e}")
            return False
    
    async def scan_file(self, filename: str, content: bytes) -> Dict:
        """
        Scan file for malware
        
        Returns:
            Dict with scan results including threat detection
        """
        result = {
            "filename": filename,
            "size": len(content),
            "is_infected": False,
            "threats": [],
            "scan_method": "heuristic",
            "file_type": None,
            "hashes": {}
        }
        
        # Get file type
        try:
            file_type = magic.from_buffer(content, mime=True)
            result["file_type"] = file_type
        except Exception as e:
            logger.error(f"Error detecting file type: {e}")
        
        # Calculate hashes
        result["hashes"] = {
            "md5": hashlib.md5(content).hexdigest(),
            "sha256": hashlib.sha256(content).hexdigest()
        }
        
        # Heuristic checks
        heuristic_result = self._heuristic_scan(filename, content)
        if heuristic_result["suspicious"]:
            result["is_infected"] = True
            result["threats"].extend(heuristic_result["indicators"])
        
        # ClamAV scan if available
        if self.use_clamav:
            try:
                clamav_result = self._clamav_scan(content)
                result["scan_method"] = "clamav"
                
                if clamav_result["infected"]:
                    result["is_infected"] = True
                    result["threats"].extend(clamav_result["threats"])
            except Exception as e:
                logger.error(f"ClamAV scan failed: {e}")
        
        return result
    
    def _clamav_scan(self, content: bytes) -> Dict:
        """Scan using ClamAV"""
        try:
            cd = clamd.ClamdNetworkSocket(
                host=settings.CLAMAV_HOST,
                port=settings.CLAMAV_PORT,
                timeout=30
            )
            
            scan_result = cd.scan_stream(content)
            
            if scan_result and 'stream' in scan_result:
                status, threat = scan_result['stream']
                if status == 'FOUND':
                    return {
                        "infected": True,
                        "threats": [threat]
                    }
            
            return {"infected": False, "threats": []}
            
        except Exception as e:
            logger.error(f"ClamAV scan error: {e}")
            raise
    
    def _heuristic_scan(self, filename: str, content: bytes) -> Dict:
        """Heuristic malware detection"""
        indicators = []
        suspicious = False
        
        filename_lower = filename.lower()
        
        # Check for suspicious file extensions
        dangerous_extensions = [
            '.exe', '.bat', '.cmd', '.com', '.scr', '.vbs', '.js',
            '.jar', '.app', '.deb', '.rpm', '.dmg', '.pkg'
        ]
        
        if any(filename_lower.endswith(ext) for ext in dangerous_extensions):
            indicators.append({
                "type": "suspicious_extension",
                "severity": "high",
                "description": f"Executable file type: {filename}"
            })
            suspicious = True
        
        # Check for double extensions
        if filename.count('.') > 1:
            parts = filename.split('.')
            if len(parts) > 2 and parts[-2] in ['pdf', 'doc', 'xls', 'jpg']:
                indicators.append({
                    "type": "double_extension",
                    "severity": "critical",
                    "description": "File has deceptive double extension"
                })
                suspicious = True
        
        # Check file size anomalies
        if len(content) < 100:
            indicators.append({
                "type": "tiny_file",
                "severity": "medium",
                "description": "Suspiciously small file size"
            })
            suspicious = True
        
        # Check for embedded executables in non-executable files
        if filename_lower.endswith(('.pdf', '.doc', '.docx', '.xls', '.xlsx')):
            # Look for PE header in content
            if b'MZ' in content[:1000]:  # PE executable header
                indicators.append({
                    "type": "embedded_executable",
                    "severity": "critical",
                    "description": "Executable code found in document"
                })
                suspicious = True
        
        # Check for suspicious strings in executables
        if filename_lower.endswith(('.exe', '.dll', '.sys')):
            suspicious_strings = [
                b'cmd.exe', b'powershell', b'regedit', b'taskkill',
                b'bitcoin', b'wallet', b'ransom', b'encrypt'
            ]
            
            found_strings = [s.decode() for s in suspicious_strings if s in content]
            if found_strings:
                indicators.append({
                    "type": "suspicious_strings",
                    "severity": "high",
                    "description": f"Suspicious strings found: {', '.join(found_strings)}"
                })
                suspicious = True
        
        # Check for packed/obfuscated executables
        if filename_lower.endswith(('.exe', '.dll')):
            # High entropy suggests packing/encryption
            entropy = self._calculate_entropy(content[:10000])
            if entropy > 7.5:  # High entropy threshold
                indicators.append({
                    "type": "high_entropy",
                    "severity": "medium",
                    "description": "File appears packed or encrypted"
                })
                suspicious = True
        
        return {
            "suspicious": suspicious,
            "indicators": indicators
        }
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0.0
        
        entropy = 0
        for x in range(256):
            p_x = float(data.count(bytes([x]))) / len(data)
            if p_x > 0:
                entropy += - p_x * (p_x ** 0.5)
        
        return entropy
    
    async def scan_url_file(self, url: str) -> Dict:
        """
        Scan a file from URL
        
        Note: In production, implement proper URL fetching with size limits
        """
        # This would fetch the URL and scan the content
        # Implement with proper safety checks
        pass